package findc{	import flash.display.Sprite;	import flash.display.MovieClip;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	public class findColor extends Sprite	{		private var red:Array = [];		private var green:Array = [];		private var blue:Array = [];		private var level:int;		private var div:int;		private var colornum;		private var w_div:int;		private var h_div:int;		private var w_num:Number;		private var h_num:Number;		private var j:int;		private var greenpoint:Point = new Point();		private var bmpdata_mid:BitmapData;		private var arearect:Rectangle;		private var point1:Point = new Point();		private var point2:Point = new Point();		private var point3:Point = new Point();		private var point4:Point = new Point();		private var fix_x:Number;		private var fix_y:Number;		private var dis1x:Number;		private var dis1y:Number;		private var dis2x:Number;		private var dis2y:Number;		private var dis3x:Number;		private var dis3y:Number;		private var array:Array = [];		private var clockwise:Boolean;		private var bmpdata:BitmapData;		public function findColor()		{		}		public function checkcolor(_bmpdata:BitmapData,_clockwise:Boolean,_fix_x:Number = 5,_fix_y:Number = 5,checkfirst:Boolean=false):Array		{			bmpdata = _bmpdata						//－－－－大致找出绿块－－－－－－－－－－－－－－－－－－－－－－－－－－			//减少像素的色值种类			/*level = 8;			div = 256 / level;			for (var i=0; i<256; i++)			{			colornum = Math.floor(i / div) * div;			red[i] = colornum << 16;			green[i] = colornum << 8;			blue[i] = colornum;			}			bmpdata.paletteMap(bmpdata,bmpdata.rect,new Point(),red,green,blue);*/			//找出红色通道含red量大于100的区域并高亮粉色;			var pt:Point = new Point(0,0);			var threshold:uint = 0x00320000;//Red为100的红色			var color:uint = 0xffff00ff;//无Green的纯粉色			var maskColor:uint = 0x00ff0000;//正红色			bmpdata.threshold(bmpdata,bmpdata.rect, pt, ">", threshold, color, maskColor, true);			//找出绿色通道含blue量大于100的区域并高亮蓝色			var pt3:Point = new Point(0,0);			var threshold3:uint = 0x00000032;//Blue为100的蓝色			var color3:uint = 0xff6400e1;//纯蓝色			var maskColor3:uint = 0x000000ff;//正蓝色			bmpdata.threshold(bmpdata,bmpdata.rect, pt3, ">", threshold3, color3, maskColor3, true);			//找出绿色通道含green量大于100的区域并高亮绿色			var pt2:Point = new Point(0,0);			var threshold2:uint = 0x00003200;//Green为100的绿色			var color2:uint = 0xff00ff00;//纯绿色			var maskColor2:uint = 0x0000ff00;//正绿色			bmpdata.threshold(bmpdata,bmpdata.rect, pt2, ">", threshold2, color2, maskColor2, true);			//this.parent.addChild(new Bitmap(bmpdata))			//－－－－精确获取绿块的四个点－－－－－－－－－－－－－－－－－－－－－－－－－－			//画格子分区域			w_div = 20;			h_div = 15;			w_num = bmpdata.width / w_div;			h_num = bmpdata.height / h_div;			//找出全是绿色的区块 ，取到第一个全绿块的中心点坐标			bmpdata_mid = new BitmapData(w_num,h_num);			for (j = 0; j < w_div*h_div; j++)			{				bmpdata_mid.draw(bmpdata,new Matrix(1,0,0,1,-j%w_div*w_num,-int(j/w_div)*h_num));				if (bmpdata_mid.getColorBoundsRect(0xff00ff00,0xff00ff00,false).width == 0)				{//只取全绿色的部分					//if(bmpdata_mid.getColorBoundsRect(0xff00ff00, 0xff00ff00).width > 0){//取含绿色的					greenpoint.x = j % w_div * w_num + w_num / 2;					greenpoint.y = int(j / w_div) * h_num + h_num / 2;					break;				}			}			if (j == w_div * h_div)			{				return [];			}			//利用绿块的点对边缘检测图进行填色			bmpdata.floodFill(greenpoint.x, greenpoint.y, 0xFF00fff0);			//确定四个点			arearect = bmpdata.getColorBoundsRect(0xFF00fff0,0xFF00fff0);			fix_x = _fix_x;			fix_y = _fix_y;			clockwise = _clockwise;			if(checkfirst){				checkPointByFirst();			}else{				checkPointByAll();			}						return array;		}				private function checkPointByFirst():void{//只检测第一个点 ，其余3点根据坐标差确定			if (clockwise)			{				point1.x = findpoint(bmpdata,arearect.x,arearect.y,0xFF00fff0,true,true)-fix_x;				point1.y = arearect.y-fix_y;			}			else			{				point1.x = findpoint(bmpdata,arearect.x + arearect.width,arearect.y,0xFF00fff0,true,false)+fix_x;				point1.y = arearect.y-fix_y;			}			point2.x = point1.x + dis1x;			point2.y = point1.y + dis1y;			point3.x = point1.x + dis2x;			point3.y = point1.y + dis2y;			point4.x = point1.x + dis3x;			point4.y = point1.y + dis3y;			array = [point1,point2,point3,point4];			trace("["+array+"],")		}				private function checkPointByAll():void{//检测所有4个点			if (clockwise)			{				point1.x = findpoint(bmpdata,arearect.x,arearect.y,0xFF00fff0,true,true)-fix_x;				point1.y = arearect.y-fix_y;				point4.x = arearect.x-fix_x;				point4.y = findpoint(bmpdata,arearect.x,arearect.y + arearect.height,0xFF00fff0,false,false)+fix_y;				point3.x = findpoint(bmpdata,arearect.x + arearect.width,arearect.y + arearect.height - 1,0xFF00fff0,true,false)+fix_x;				point3.y = arearect.y + arearect.height+fix_y;				point2.x = arearect.x + arearect.width+fix_x;				point2.y = findpoint(bmpdata,arearect.x + arearect.width - 1,arearect.y,0xFF00fff0,false,true)-fix_y;			}			else			{				point1.x = findpoint(bmpdata,arearect.x + arearect.width,arearect.y,0xFF00fff0,true,false)+fix_x;				point1.y = arearect.y-fix_y;				point2.x = arearect.x-fix_x;				point2.y = findpoint(bmpdata,arearect.x,arearect.y,0xFF00fff0,false,true)-fix_y;				point3.x = findpoint(bmpdata,arearect.x,arearect.y + arearect.height - 1,0xFF00fff0,true,true)-fix_x;				point3.y = arearect.y + arearect.height+fix_y;				point4.x = arearect.x + arearect.width+fix_x;				point4.y = findpoint(bmpdata,arearect.x + arearect.width - 1,arearect.y + arearect.height,0xFF00fff0,false,false)+fix_y;			}			dis1x = point2.x - point1.x;			dis1y = point2.y - point1.y;			dis2x = point3.x - point1.x;			dis2y = point3.y - point1.y;			dis3x = point4.x - point1.x;			dis3y = point4.y - point1.y;			array = [point1,point2,point3,point4];			trace("["+array+"],")		}		private function findpoint(bmpdata:BitmapData,startx:Number,starty:Number,color:uint,xory:Boolean,lefttoright:Boolean):Number		{			var m:int;			var returnnum:Number;			if (xory)			{//延x轴搜索				if (lefttoright)				{					for (m = startx; m<1000; m++)					{						if (bmpdata.getPixel32(m,starty).toString(16) == color.toString(16))						{							returnnum = m;							return returnnum;						}					}				}				else				{					for (m = startx; m>0; m--)					{						if (bmpdata.getPixel32(m,starty).toString(16) == color.toString(16))						{							returnnum = m;							return returnnum;						}					}				}			}			else			{				if (lefttoright)				{					for (m = starty; m<1000; m++)					{						if (bmpdata.getPixel32(startx,m).toString(16) == color.toString(16))						{							returnnum = m;							return returnnum;						}					}				}				else				{					for (m = starty; m>0; m--)					{						if (bmpdata.getPixel32(startx,m).toString(16) == color.toString(16))						{							returnnum = m;							return returnnum;						}					}				}			}			return 0;		}	}}