package findc{	import flash.display.Sprite;	import flash.display.BitmapData;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	import findc.fevent.fcEvent;	import flash.events.Event;	import flash.events.EventDispatcher;		public class findColor extends Sprite	{		private var red:Array = [];		private var green:Array = [];		private var blue:Array = [];		private var level:int;		private var div:int;		private var colornum;		private var w_div:int;		private var h_div:int;		private var w_num:Number;		private var h_num:Number;		private var j:int;		private var greenpoint:Point = new Point();		private var bmpdata_mid:BitmapData;		private var arearect:Rectangle;		private var point1:Point = new Point();		private var point2:Point = new Point();		private var point3:Point = new Point();		private var point4:Point = new Point();		public function findColor()		{					}				public function checkcolor(bmpdata:BitmapData):Array{			//－－－－大致找出绿块－－－－－－－－－－－－－－－－－－－－－－－－－－			//减少像素的色值种类			level = 8;			div = 256 / level;			for (var i=0; i<256; i++)			{				colornum = Math.floor(i / div) * div;				red[i] = colornum << 16;				green[i] = colornum << 8;				blue[i] = colornum;			}			bmpdata.paletteMap(bmpdata,bmpdata.rect,new Point(),red,green,blue);			//找出红色通道含red量大于100的区域并高亮粉色;			var pt:Point = new Point(0,0);			var threshold:uint = 0x00640000;//Red为100的红色			var color:uint = 0xffff00ff;//无Green的纯粉色			var maskColor:uint = 0x00ff0000;//正红色			bmpdata.threshold(bmpdata,bmpdata.rect, pt, ">", threshold, color, maskColor, true);			//找出绿色通道含green量大于100的区域并高亮绿色			var pt2:Point = new Point(0,0);			var threshold2:uint = 0x00003200;//Green为100的绿色			var color2:uint = 0xff00ff00;//纯绿色			var maskColor2:uint = 0x0000ff00;//正绿色			bmpdata.threshold(bmpdata,bmpdata.rect, pt2, ">", threshold2, color2, maskColor2, true);			//－－－－精确获取绿块的四个点－－－－－－－－－－－－－－－－－－－－－－－－－－			//画格子分区域			w_div = 15;			h_div = 10;			w_num = bmpdata.width / w_div;			h_num = bmpdata.height / h_div;			//找出全是绿色的区块 ，取到第一个全绿块的中心点坐标			bmpdata_mid = new BitmapData(w_num,h_num);			for (j = 0; j < w_div*h_div; j++)			{				bmpdata_mid.draw(bmpdata,new Matrix(1,0,0,1,-j%w_div*w_num,-int(j/w_div)*h_num));				if (bmpdata_mid.getColorBoundsRect(0xff00ff00,0xff00ff00,false).width == 0)				{//只取全绿色的部分					//if(bmpdata_mid.getColorBoundsRect(0xff00ff00, 0xff00ff00).width > 0){//取含绿色的					greenpoint.x = j % w_div * w_num + w_num / 2;					greenpoint.y = int(j / w_div) * h_num + h_num / 2;					break;				}			}						//利用绿块的点对边缘检测图进行填色			bmpdata.floodFill(greenpoint.x, greenpoint.y, 0xFF00fff0);			//确定四个点			arearect = bmpdata.getColorBoundsRect(0xFF00fff0,0xFF00fff0);			point1.x = findpoint(bmpdata,arearect.x,arearect.y,0xFF00fff0,true,true);			point1.y = arearect.y;			point2.x = arearect.x;			point2.y = findpoint(bmpdata,arearect.x,arearect.y,0xFF00fff0,false,true);			point3.x = findpoint(bmpdata,arearect.x + arearect.width,arearect.y + arearect.height - 1,0xFF00fff0,true,false);			point3.y = arearect.y + arearect.height;			point4.x = arearect.x + arearect.width;			point4.y = findpoint(bmpdata,arearect.x + arearect.width - 1,arearect.y + arearect.height,0xFF00fff0,false,false);						var array:Array = [point1,point2,point3,point4];			return array;		}		private function findpoint(bmpdata:BitmapData,startx:Number,starty:Number,color:uint,xory:Boolean,lefttoright:Boolean):Number		{			var m:int;			var returnnum:Number;			if (xory)			{//延x轴搜索				if (lefttoright)				{					for (m = startx; m<1000; m++)					{						if (bmpdata.getPixel32(m,starty).toString(16) == color.toString(16))						{							returnnum = m;							return returnnum;						}					}				}				else				{					for (m = startx; m>0; m--)					{						if (bmpdata.getPixel32(m,starty).toString(16) == color.toString(16))						{							returnnum = m;							return returnnum;						}					}				}			}			else			{				if (lefttoright)				{					for (m = starty; m<1000; m++)					{						if (bmpdata.getPixel32(startx,m).toString(16) == color.toString(16))						{							returnnum = m;							return returnnum;						}					}				}				else				{					for (m = starty; m>0; m--)					{						if (bmpdata.getPixel32(startx,m).toString(16) == color.toString(16))						{							returnnum = m;							return returnnum;						}					}				}			}			return 0;		}	}}